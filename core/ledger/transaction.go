package ledger

import (
	"crypto/ecdsa"
	"digisocialblock/core/identity" // Assuming this path for identity package
	"fmt"
	"time"
)

// NewTransaction creates a new transaction with the given parameters.
// The ID is generated by hashing the core content (timestamp, sender, type, payload).
// The signature is initially nil and should be set by calling Sign.
func NewTransaction(senderPublicKey string, txType TransactionType, payload []byte) (*Transaction, error) {
	if senderPublicKey == "" {
		return nil, fmt.Errorf("sender public key cannot be empty")
	}
	if txType == "" {
		return nil, fmt.Errorf("transaction type cannot be empty")
	}

	ts := time.Now().UnixNano()
	tx := &Transaction{
		Timestamp:       ts,
		SenderPublicKey: senderPublicKey, // This is the hex string address from identity.PublicKeyToAddress
		Type:            txType,
		Payload:         payload,
		Signature:       nil, // Signature to be added later
	}

	// Calculate ID based on content (excluding signature and ID itself)
	tx.ID = HashTransactionContent(tx.Timestamp, tx.SenderPublicKey, tx.Type, tx.Payload)
	return tx, nil
}

// Sign populates the Signature field of the transaction using a provided ECDSA private key.
// The data signed is the transaction ID (which is a hash of its content).
func (tx *Transaction) Sign(privateKey *ecdsa.PrivateKey) error {
	if tx.ID == "" {
		return fmt.Errorf("transaction ID is empty, cannot sign")
	}
	if privateKey == nil {
		return fmt.Errorf("private key is nil, cannot sign")
	}

	dataToSign := []byte(tx.ID) // Hash of the transaction content (its ID)

	// ecdsa.SignASN1 signs a hash (which tx.ID is) and returns the ASN.1 DER encoded signature.
	// This is a common way to store ECDSA signatures.
	signature, err := ecdsa.SignASN1(identity.GetRandReader(), privateKey, dataToSign)
	if err != nil {
		return fmt.Errorf("failed to sign transaction data: %w", err)
	}
	tx.Signature = signature
	return nil
}

// VerifySignature checks if the transaction's signature is valid against its content (ID)
// and the sender's public key.
func (tx *Transaction) VerifySignature() (bool, error) {
	if tx.ID == "" {
		return false, fmt.Errorf("transaction ID is empty, cannot verify signature")
	}
	if tx.SenderPublicKey == "" {
		return false, fmt.Errorf("sender public key (address) is empty, cannot verify signature")
	}
	if len(tx.Signature) == 0 {
		return false, fmt.Errorf("signature is empty, cannot verify")
	}

	// Convert the hex-encoded public key string (address) back to an *ecdsa.PublicKey
	publicKey, err := identity.AddressToPublicKey(tx.SenderPublicKey)
	if err != nil {
		return false, fmt.Errorf("failed to parse sender public key from address '%s': %w", tx.SenderPublicKey, err)
	}

	dataToVerify := []byte(tx.ID) // The data that was signed is the transaction ID

	// ecdsa.VerifyASN1 verifies an ASN.1 DER encoded signature.
	isValid := ecdsa.VerifyASN1(publicKey, dataToVerify, tx.Signature)
	if !isValid {
		return false, fmt.Errorf("ECDSA signature verification failed") // Specific error for failed verification
	}
	return true, nil
}


// IsValid performs basic validation checks on the transaction.
// This does not include signature verification here, as that might be context-dependent
// (e.g., you might validate structure before bothering with crypto).
func (tx *Transaction) IsValid() error {
	if tx.ID == "" {
		return fmt.Errorf("transaction has empty ID")
	}
	// Check if calculated ID matches the current content (if ID was pre-set and content changed)
	// This is more of an internal consistency check if the tx was mutated after ID calculation.
	// currentContentHash := HashTransactionContent(tx.Timestamp, tx.SenderPublicKey, tx.Type, tx.Payload)
	// if tx.ID != currentContentHash {
	// 	return fmt.Errorf("transaction ID mismatch: recorded %s, calculated %s", tx.ID, currentContentHash)
	// }
	if tx.Timestamp <= 0 {
		return fmt.Errorf("transaction has invalid timestamp: %d", tx.Timestamp)
	}
	if tx.SenderPublicKey == "" {
		return fmt.Errorf("transaction has empty sender public key")
	}
	if tx.Type == "" {
		return fmt.Errorf("transaction has empty type")
	}
	// Payload can be empty for certain transaction types, so not checking len(tx.Payload) == 0 by default.
	return nil
}
